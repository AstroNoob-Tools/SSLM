# FITS Analyzer Project: Technical Report

## 1. Technical Description of the Problem

### Context: Astronomical Imaging variability
In deep-sky astrophotography, the final image is created by "stacking" (averaging) hundreds or thousands of short exposures (sub-frames). The quality of these individual sub-frames varies significantly due to dynamic factors:
-   **Atmospheric Seeing**: Turbulence in the atmosphere blurs starlight, increasing the Full Width at Half Maximum (FWHM) of stars.
-   **Wind Shake**: Physical movement of the telescope setup.
-   **Tracking Errors**: Imperfections in the mount's tracking of the sky rotation.
-   **Focus Drift**: Changes in focus due to temperature shifts.

### The Challenge
Including poor-quality frames (those with bloated stars or trails) in the final stack degrades the overall resolution and Signal-to-Noise Ratio (SNR) of the image.

**Objective**: To automate the quality assessment of FITS images generated by a Seestar S50 telescope, specifically using the **FWHM** metric as a proxy for image sharpness, and isolate the top percentage of high-quality frames for processing.

---

## 2. Technical Solution Chosen and Rationale

We evaluated two potential architectures: a pure JavaScript/Node.js solution versus a Hybrid Node.js/Python architecture.

### Selected Architecture: Hybrid Node.js + Python
We chose to implement the core scientific logic in **Python**, while wrapping it in **Node.js** for integration into the existing application stack.

### Why Python?
1.  **Mature Scientific Ecosystem**: Python's `astropy` library is the industry standard for astronomical data handling. It provides battle-tested implementations of FITS I/O, World Coordinate Systems (WCS), and physical constants.
2.  **Advanced PSF Modeling**: The `astropy.modeling` module includes robust implementations of **Moffat2D** profiles.
    -   *Crucial Detail*: We initially tested simple Gaussian fitting, but it systematically underestimated star sizes because it fails to model the "wings" of starlight caused by atmospheric scattering. The **Moffat distribution** provides a physically accurate model for ground-based telescope data, significantly improving FWHM accuracy (Median FWHM improved from ~10.2" to ~8.4" in tests).
3.  **Efficiency**: While JavaScript can parse FITS files (`fitsjs`), implementing complex non-linear least-squares fitting (Levenberg-Marquardt algorithm) for 2D Moffat profiles in JS would require custom, error-prone implementations or unoptimized generic libraries.

### PSF Model Specifications & Selection
The system supports multiple PSF models to accommodate different observing conditions. The user can select the model via configuration.

#### 1. Moffat2D (Default & Recommended)
**Most common for ground-based astronomy.** It accurately models the "wings" of the star profile caused by atmospheric turbulence.
-   **Parameters**:
    -   `amplitude`: Peak flux intensity (ADU).
    -   `x_0`, `y_0`: Centroid position (pixel coordinates).
    -   `gamma`: Core width parameter.
    -   `alpha`: Power index (controls wing shape).
-   **Defaults & Ranges (Seestar S50)**:
    -   `alpha`: **Default 2.5**. Range: [1.5, 4.765] (lower = broader wings).
    -   `gamma`: **Default ~1.5**. Range: [0.5, 5.0] pixels.

#### 2. Gaussian2D
**Common for simple estimates or space-based data.**
-   **Parameters**:
    -   `amplitude`: Peak flux (ADU).
    -   `x_mean`, `y_mean`: Centroid position.
    -   `x_stddev`, `y_stddev`: Standard deviation (width).
    -   `theta`: Rotation angle (radians).
-   **Defaults & Ranges**:
    -   `x_stddev`, `y_stddev`: **Default ~1.0**. Range: [0.5, 3.0] pixels.

#### 3. Lorentzian2D
**Used for specific optical systems or extreme scattering.**
-   **Implementation**: Modeled as a Moffat2D profile with `alpha` fixed to 1.0.
-   **Parameters**:
    -   `amplitude`
    -   `x_0`, `y_0`
    -   `gamma` (HWHM)
-   **Defaults & Ranges**:
    -   `gamma`: **Default ~1.5**. Range: [0.5, 5.0] pixels.

#### 4. Voigt2D
**Convolution of Gaussian and Lorentzian.**
-   **Status**: Experimental.

### Alternative Quality Metrics
While **FWHM** (sharpness) is the primary metric, other factors are critical for a high-quality stack.

#### 1. Eccentricity / Roundness
-   **What it measures**: The elongation of stars.
-   **Why it matters**: Detects tracking errors, wind shake, or field rotation. A frame might have good FWHM but oval stars (trails), which ruins the stack.
-   **Goal**: Eccentricity < 0.42 (approx) is considered round.

#### 2. Signal-to-Noise Ratio (SNR)
-   **What it measures**: Calculate the ratio of signal (star flux) to background noise.
-   **Why it matters**: Higher SNR frames contribute more to the final image depth. Low SNR frames (e.g., passing clouds) degrade the result.

#### 3. Star Count
-   **What it measures**: Number of detected sources above threshold.
-   **Why it matters**: A sudden drop in star count often indicates passing thin clouds (transparency loss) even if FWHM/Focus remains good.

#### 4. Background Mean/Median
-   **What it measures**: Sky brightness.
-   **Why it matters**: Sudden increases indicate light pollution gradients, moon interference, or clouds reflecting city light.

### Advanced Feature: Evolutive Selection Engine
We propose an "Evolutive Selection" mechanism that moves beyond simple FWHM sorting. This engine dynamically combines multiple metrics to select the optimal set of frames based on a **Weighted Quality Score**.

#### How it works
Instead of a single cutoff (e.g., "Top 80% by FWHM"), the engine calculates a composite score for each frame:

```
Quality_Score = (w_fwhm * Norm_FWHM) + (w_ecc * Norm_Eccentricity) + (w_snr * Norm_SNR) + (w_stars * Norm_StarCount)
```
*Where `Norm_X` is the normalized value of metric X (0.0 to 1.0).*

#### Selection Strategy
1.  **Hard Rejection (Pass 1)**: Automatically discard any frame that violates critical thresholds (e.g., `Eccentricity > 0.6` or `StarCount < 50`).
2.  **Weighted Sorting (Pass 2)**: Rank remaining frames by `Quality_Score`.
3.  **Adaptive Cutoff (Pass 3)**:
    -   Select top `N%` frames.
    -   **Evolution**: If the resulting set has high variance (e.g., includes some blurry frames), the engine *tightens* the FWHM weight and re-runs the selection.
    -   Example: "I need 100 frames. If the 100th frame has FWHM > 5.0", drop it and take the next best, or stop at 90 frames."

#### The Reference Frame Strategy
Following the initial scoring, the engine identifies the single best frame (highest Score) as the **Reference Frame**.
1.  **Normalization**: All other frames are re-evaluated relative to this reference.
    -   `Relative_Score = Frame_Score / Reference_Score * 100`
2.  **Final Cutoff**: The user can set a simple threshold: "Keep all frames that are at least 80% as good as the reference."
    -   This handles varying night conditions better than absolute values. A "bad" night might have a reference FWHM of 4.0", while a "good" night has 2.0". The relative score adapts to the session's best possible quality.

This ensures the final stack is not just sharp, but also round (good tracking) and deep (good SNR).

### Why Node.js Integration?
The user's existing application environment is JavaScript-based. By using Node.js as the orchestrator:
-   We maintain compatibility with the existing system.
-   We leverage Node's non-blocking I/O to handle file system operations efficiently while offloading CPU-intensive math to Python processes.

---

## 3. Implementation Plan & System Architecture

The project consists of three main components:

### A. Core Analysis Module
This is the scientific engine.
-   **Input**: Single FITS file path.
-   **Process**:
    1.  **Data Ingestion**: Reads FITS header for focal length/pixel size to calculate plate scale.
    2.  **Preprocessing**: Estimates background noise using sigma-clipped statistics.
    3.  **Source Detection**: Uses star finding algorithms (e.g., DAOFIND) to detect star-like sources above a signal-to-noise threshold.
    4.  **PSF Fitting**: Extracts cutouts of the brightest stars and fits a selected 2D Model to each.
    5.  **Aggregation**: Returns the median FWHM in both pixels and arcseconds.
-   **Output**: Structured data object (JSON) with metrics.

### B. Batch Processing Engine
Handles bulk operations to minimize overhead.
-   **Function**: Scans a directory, iteratively calls the analysis logic, and performs sorting.
-   **Optimization**: Loading the analysis environment (e.g., Python runtime and libraries) can be slow. This engine processes *all* files in a single execution context, maximizing throughput.
-   **Configuration**:
    -   **Model Selection**: The user **must** be able to select the PSF model used for fitting via configuration. Supported models include:
        -   **Moffat2D** (Default, recommended for ground-based data)
        -   **Gaussian2D** (Common standard)
        -   **Lorentzian2D** / **Voigt2D** (Alternative profiles)
    -   **Cutoff Percentage**: Configurable threshold for frame selection.
-   **Logic**:
    -   Sorts all frames by Quality Score.
    -   Selects the top percentage or absolute count.
    -   Organizes selected frames into a destination directory.
-   **Output**: Summary report of accepted/rejected files.

### C. Application Integration Layer
The interface for the host application.
-   Invokes the Batch Processing Engine.
-   Parses the output stream.
-   Provides native asynchronous patterns for the host application to consume the results.

### Deployment Requirements
-   Python 3.8+
-   Libraries: `astropy`, `numpy`, `scipy`, `photutils`
-   Node.js 14+
